#!/usr/bin/env python3

import os
import sys
import yaml
import shutil
import argparse
import subprocess
from pathlib import Path
from typing import Any, Iterable
from snakemake.utils import validate

__version__ = "1.1.2"

# Follow symlinks to install dir.
WD = Path(__file__).resolve().parent
CFG = WD.joinpath("config", "config_template.yaml")
CFG_SCHEMA = WD.joinpath("config", "config.schema.yaml")
HMM_PROFILE_SF = WD.joinpath("data", "models", "AS-SFs-hmmer3.0.290621.hmm.gz")
HMM_PROFILE_HOR = WD.joinpath("data", "models", "AS-HORs-hmmer3.4-071024.hmm.gz")
CHRS = [f"chr{c}" for c in [*range(1, 23), "X", "Y"]]
CFG_DIR = Path("config")
DATA_DIR = Path("0-symlink_inputs")

# https://manytools.org/hacker-tools/ascii-banner/
"""
Colossal.flf (Jonathon - jon@mq.edu.au)
8 June 1994

Explanation of first line:
flf2 - "magic number" for file identification
a    - should always be `a', for now
$    - the "hardblank" -- prints as a blank, but can't be smushed
11   - height of a character
8    - height of a character, not including descenders
20   - max line length (excluding comment lines) + a fudge factor
32   - default smushmode for this font
13   - number of comment lines

---

Font modified June 17, 2007 by patorjk
This was to widen the space character.
"""
ASCII_ART = """
 .d8888b.                    888b     d888        d8888 8888888b.
d88P  Y88b                   8888b   d8888       d88888 888   Y88b
888    888                   88888b.d88888      d88P888 888    888
888         .d88b.  88888b.  888Y88888P888     d88P 888 888   d88P
888        d8P  Y8b 888 "88b 888 Y888P 888    d88P  888 8888888P"
888    888 88888888 888  888 888  Y8P  888   d88P   888 888
Y88b  d88P Y8b.     888  888 888   "   888  d8888888888 888
 "Y8888P"   "Y8888  888  888 888       888 d88P     888 888
"""


def symlink_files(
    files: Iterable[str], output_dir: Path, output_fofn: Path | None = None
) -> None:
    os.makedirs(output_dir, exist_ok=True)
    symlinked_files: list[Path] = []
    for file in files:
        bname = os.path.basename(file)
        symlinked_file = output_dir.joinpath(bname)
        try:
            symlinked_file.symlink_to(os.path.abspath(file))
        except FileExistsError:
            print(f"File exists: {file}", file=sys.stderr)

        symlinked_file = output_dir.joinpath(bname)
        symlinked_files.append(symlinked_file)

    if output_fofn:
        with open(output_fofn, "wt") as fh:
            for symlinked_file in symlinked_files:
                print(str(symlinked_file), file=fh)


def update_relative_to_wd(
    cfg: dict[str, Any], working_dir: Path, config_dir: Path
) -> None:
    # Make config dir.
    new_dir = working_dir.joinpath(config_dir)
    new_dir.mkdir(exist_ok=True, parents=True)
    # Go through top-level paths and ensure relative to script.
    for _, v in cfg.items():
        if isinstance(v, dict):
            for k2, v2 in v.items():
                if not isinstance(v2, str):
                    continue
                cfg_str = WD.joinpath(v2)
                if not cfg_str.is_file():
                    continue
                new_path = new_dir.joinpath(os.path.basename(v2)).resolve()
                shutil.copy(cfg_str, new_path)
                v[k2] = str(new_path)


def make_config(
    args: argparse.Namespace, working_dir: str, template_config: Path
) -> Path:
    sample = args.sample
    if not args.sample:
        raise ValueError("Sample name is required.")

    fasta_files: list[str] | None = args.input_asm
    if not fasta_files:
        raise RuntimeError("No assembly files provided.")

    ont_files: list[str] | None = args.ont
    hifi_files: list[str] | None = args.hifi
    mode = args.mode
    output_dir = Path(working_dir, args.output_dir, sample).resolve()
    data_dir = output_dir.joinpath("data")
    new_cfg = output_dir.joinpath("config.yaml")

    # Don't overwrite if exists.
    if new_cfg.exists() and new_cfg.stat().st_size != 0:
        return new_cfg

    output_dir.mkdir(exist_ok=True, parents=True)

    with open(template_config, "rt") as fh:
        cfg: dict[str, Any] = yaml.safe_load(fh)

    # Validate and fill config.
    validate(cfg, schema=CFG_SCHEMA, set_default=True)

    # humas_annot
    if mode == "human":
        cfg["humas_annot"]["mode"] = "sd"
        cfg["humas_annot"]["hmm_profile"] = str(HMM_PROFILE_HOR)
    else:
        cfg["repeatmasker"]["species"] = "primates"
        cfg["humas_annot"]["mode"] = "sf"
        cfg["humas_annot"]["hmm_profile"] = str(HMM_PROFILE_SF)

    # Set to no chromosomes.
    # Use SF instead of srf-n-trf
    if "none" in args.chromosomes:
        chroms = []
        cfg["humas_annot"]["mode"] = "sf"
        cfg["humas_annot"]["hmm_profile"] = str(HMM_PROFILE_SF)
    else:
        chroms = args.chromosomes

    update_relative_to_wd(cfg=cfg, working_dir=output_dir, config_dir=CFG_DIR)

    # Set reference.
    # If no reference and chromosomes is []. No reference alignment is performed.
    if args.reference:
        cfg["ident_cen_ctgs"]["reference"] = args.reference

    # Symlink fasta, hifi, and ont files
    # concat_asm
    asm_dir = data_dir.joinpath("asm", sample)
    symlink_files(fasta_files, asm_dir)
    cfg["concat_asm"]["input_dir"] = asm_dir.parent.as_posix()

    # nucflag
    if hifi_files:
        hifi_dir = data_dir.joinpath("hifi", sample)
        hifi_fofn = Path(f"{hifi_dir}.fofn")
        symlink_files(hifi_files, hifi_dir, hifi_fofn)
        cfg["nucflag"]["input_hifi_reads_fofn_dir"] = hifi_fofn.parent.as_posix()
    else:
        cfg.pop("nucflag")

    # cdr_finder
    if ont_files:
        ont_dir = data_dir.joinpath("ont", sample)
        symlink_files(ont_files, ont_dir)
        cfg["cdr_finder"]["input_bam_dir"] = ont_dir.parent.as_posix()
    else:
        cfg.pop("cdr_finder")

    # Create new config.
    with open(new_cfg, "wt") as ofh:
        # Snakemake runs in results dir.
        cfg["output_dir"] = "results"
        cfg["samples"] = [sample]
        cfg["chromosomes"] = chroms
        yaml.safe_dump(cfg, ofh)

    return new_cfg


def main() -> int:
    print(f"\033[31m{ASCII_ART}\033[0m", file=sys.stderr)
    ap = argparse.ArgumentParser(
        description="(Cen)tromere (M)apping and (A)nnotation (P)ipeline."
    )
    group_data = ap.add_argument_group(
        title="Data", description="Input data arguments."
    )

    group_infiles = group_data.add_mutually_exclusive_group()
    group_infiles.add_argument(
        "-i",
        "--input-asm",
        type=str,
        dest="input_asm",
        nargs="+",
        help="Input assembly files for one sample. Supports fasta, fasta.gz, fa, or fa.gz.",
    )
    group_infiles.add_argument(
        "-c",
        "--config",
        type=str,
        help="Input configfile. If provided, other arguments are ignored. Allows submission of multiple samples or parameter tuning.",
    )
    ap.add_argument(
        "-g",
        "--generate-config",
        dest="generate_config",
        action="store_true",
        help="Generate template configfile for --config.",
    )
    group_data.add_argument(
        "--hifi",
        type=str,
        nargs="*",
        help="Input PacBio HiFi reads for assembly evaluation with NucFlag. Supports BAM, CRAM, or gzipped/gunzipped fastq/fasta files.",
    )
    group_data.add_argument(
        "--ont",
        type=str,
        nargs="*",
        help="Input ONT reads with MM and ML tags for CDR detection. Supports BAM only.",
    )
    group_data.add_argument(
        "--reference",
        type=str,
        default=None,
        help=(
            "Path to reference assembly used to rename and reorient contigs. "
            "Defaults to CHM13 v2.0 and assumes contig names are exact matches to --chromosomes. "
            "If not provided and --chromosomes set to 'none', no reference chromosome mapping is performed. "
            "Avoid changing unless you know what you're doing."
        ),
    )

    group_config = ap.add_argument_group(
        title="Configuration", description="Configuration arguments."
    )
    group_config.add_argument(
        "-s", "--sample", type=str, default=None, help="Sample name."
    )
    group_config.add_argument(
        "--chromosomes",
        type=str,
        nargs="+",
        default=CHRS,
        help="Chromosomes to partition outputs. Specifying 'none' will not partition output. Format: 'chr[0-9XY]+|none'",
    )
    group_config.add_argument(
        "-m",
        "--mode",
        type=str,
        default="human",
        choices=["human", "nhp"],
        help="Species of sample. Either 'human' or non-human primate ('nhp').",
    )
    wf_config = ap.add_argument_group(
        title="Workflow", description="Workflow configuration arguments."
    )
    wf_config.add_argument(
        "-o",
        "--output-dir",
        dest="output_dir",
        default="results",
        type=str,
        help="Output directory.",
    )
    group_processes = wf_config.add_mutually_exclusive_group()
    group_processes.add_argument(
        "-p", "--processes", type=int, default=24, help="Number of processes to run."
    )
    group_processes.add_argument(
        "-j",
        "--jobs",
        type=int,
        default=24,
        help="Number of jobs to run. Requires setting --workflow-profile and one of the snakemake cluster plugins.",
    )

    wf_config.add_argument(
        "--workflow-profile",
        dest="workflow_profile",
        type=str,
        default=None,
        help="Custom workflow profile for snakemake.",
    )
    wf_config.add_argument(
        "--snake-opts",
        dest="snake_opts",
        type=str,
        default=None,
        help="Additional snakemake options.",
    )
    ap.add_argument(
        "-v",
        "--version",
        action="version",
        help="Show version and exit.",
        version=f"{__version__}",
    )
    args = ap.parse_args()
    cwd = os.getcwd()

    if args.config:
        new_config = Path(args.config).resolve()
        print(f"Using existing configfile:\n\t{new_config}", file=sys.stderr)
        with open(new_config, "rt") as fh:
            cfg: dict[str, Any] = yaml.safe_load(fh)
            output_dir = Path(cfg.get("output_dir", args.output_dir))
            samples = cfg.get("samples", [])
            assert len(samples) != 0, "No sample provided."
    elif args.generate_config:
        with open(CFG, "rt") as fh:
            cfg = yaml.safe_load(fh)
            output_dir = Path(args.output_dir)
            # Transfer config to working dir
            update_relative_to_wd(cfg=cfg, working_dir=output_dir, config_dir=CFG_DIR)
            # Copy both profiles so user
            for file in (HMM_PROFILE_HOR, HMM_PROFILE_SF):
                bname = os.path.basename(file)
                outfile = output_dir.joinpath(CFG_DIR, bname)
                if output_dir.joinpath(CFG_DIR, bname).exists():
                    continue
                shutil.copy(file, outfile)
            # No samples
            cfg["samples"] = []
            yaml.safe_dump(cfg, sys.stdout)
            print(
                "Printed template config to stdout! Update the following fields, comment optional blocks if desired, and add data before running:\n",
                "1. concat_asm.input_dir\n",
                " * REQUIRED\n",
                " * ex. data/asm\n",
                " * data: {concat_asm.input_dir}/{sm}/{asm}.[fa|fasta|fa.gz|fasta.gz])\n",
                "2. samples\n",
                " * REQUIRED\n",
                " * ex. [HG002]\n",
                "3. nucflag.input_hifi_reads_fofn_dir\n",
                " * OPTIONAL\n",
                " * ex. data/hifi\n",
                " * data: {nucflag.input_hifi_reads_fofn_dir}/{sm}.fofn\n",
                "4. cdr_finder.input_bam_dir\n",
                " * OPTIONAL\n",
                " * ex. data/ont/{sm}/{read}.bam\n",
                " * data: {cdr_finder.input_bam_dir}/{sm}.fofn",
                file=sys.stderr,
            )
            return 0
    else:
        new_config = make_config(args, working_dir=cwd, template_config=CFG).absolute()
        samples = [args.sample]
        print(f"Generated configfile:\n\t{new_config}", file=sys.stderr)
        output_dir = Path(args.output_dir, args.sample)

    output_dir.mkdir(exist_ok=True, parents=True)

    # Copy workflow directory to results.
    try:
        shutil.copy(
            src=WD.joinpath("config", "config.schema.yaml"),
            dst=output_dir.joinpath("config", "config.schema.yaml")
        )
        shutil.copytree(
            src=WD.joinpath("workflow"),
            dst=output_dir.joinpath("workflow"),
        )
    except FileExistsError:
        pass

    if not args.workflow_profile:
        profile = "workflow/profiles/all"
    else:
        profile = args.workflow_profile

    if args.workflow_profile and args.jobs:
        process_args = ["-j", str(args.jobs)]
    else:
        process_args = ["-c", str(args.processes)]

    cmd = [
        "snakemake",
        "--configfile",
        new_config.as_posix(),
        *process_args,
        "--workflow-profile",
        profile,
    ]
    snake_opts = []
    if args.snake_opts:
        snake_opts = args.snake_opts.split(" ")
        cmd.extend(snake_opts)

    print(f"Running command:\n\t{' '.join(cmd)}", file=sys.stderr)
    print(f"Output dir:\n\t{output_dir}", file=sys.stderr)
    print(
        f"With sample(s):\n\t{'\n\t'.join(samples)}",
        file=sys.stderr,
    )
    try:
        subprocess.run(cmd, check=True, cwd=output_dir)
    except subprocess.CalledProcessError:
        subprocess.run([*cmd, "--unlock"], check=True, cwd=output_dir)
        return -1

    # Don't delete temp files if dry-run.
    is_dryrun = (
        any("n" in opt for opt in snake_opts if opt.count("-") == 1)
        or "--dry-run" in snake_opts
        or "--dryrun" in snake_opts
    )
    if is_dryrun:
        return 0

    print("Cleaning up temp files.", file=sys.stderr)
    subprocess.run(
        ["snakemake", "--configfile", new_config.as_posix(), "--delete-temp-output"],
        check=True,
        cwd=output_dir,
    )

    print("Finished!", file=sys.stderr)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
